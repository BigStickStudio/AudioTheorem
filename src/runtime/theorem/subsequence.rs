// Disposition is a Music Theory concept that is used to determine the color of the note (later might add a fractional degree or mixing of colors as a vector) << -- we are incorporating this through pitchgroups and scales
// The intent and purpose of this system, alongside the sequence Data, is to interface the pitchgroups and scales with the audio and graphics systems to help correlate
// the color of the notes with the sound and the key of the music. This is a proprietary system that is being developed for the Ancillary via Big Stick Studios, and is not to be used without permission.

// Copyright (c) 2024 by Richard I Christopher, Big Stick Studio - All Rights Reserved, Proprietary License - The NEXUS Project

/*  Proposed Questions 
    - can we use audio structure as an indicator for an AI system to learn to analyze speech patterns, emotion, phonetics, and intent?
    - Is there a correlation to audio and emotion?
    - Can we prove that life comes from Oxygon and Hydrogen when met with Carbon and Nitrogen?
    - Will I make my first million before I'm 35?
*/

use crate::types::{Tone, Scale, Interval};
use super::chord::Chord;

// These could tell us where on the screen or spectrum the note should be placed
// and how intense the color should be <spatial audio == color == 3-5-7-9-11-13.. <===> 0-2-4-6-8-10-12..>
#[derive(Copy, Clone, Debug)]
pub struct Disposition {
    pub tone: Tone,         // This is the actual "natural" Note that is being played, defined by the index and velocity
        // How we interpret and define Harmony has to depend on the filter we are using but for now we are slave to the pitchgroup kernel
    pub harmony: u8,       // This is the type of note instance - 0 = Played, 1 = Harmonious, 255 = Nonce
    // This is likely where we will add a [f32; 10] for the 100 cents of a given pitchclass if we implement that level of resolution
}

#[derive(Clone, Debug)]
pub struct Subsequence {
    pub disposition: Vec<Disposition>, // // This is the indicator for the color of the note -  // We may have to make this a HashMap for the index and r/w
    chords: Vec<Chord>,                     // These are the inversions from the notes we are playing        -   we need to combine
    scales: Vec<Scale>,                     // TODO: This is the collection of scales from the given intervals  -     these two types
}

impl Subsequence {
    pub fn clear(&mut self) { self.iv.clear(); }

    // We are going to return a true if we succeeded, which will escape the parent function - determined by max/min index
    pub fn play_note(&mut self, index: u8, velocity: u8, dissidence: f32) -> bool
        {
            // if we have a note in our 'scope' already then we just want to pick the higher velocity
            // so, we need to check if the index is already in the vector
            if let Some(position) = self.disposition.iter_mut().find(|d| d.index == index) // Does this work?
                { 
                    // if it is, we need to update the velocity if it is greater, and exit.
                    if position.tone.velocity < velocity { position.tone.velocity = velocity; }
                    return;
                }

            // somehow we're going to have to determine the distance between the indices before we add them

            // otherwise, add it
            self.disposition.push(Disposition{tone: Tone::from_iv(index, velocity), harmony: 0});
        }

    pub fn remove(&mut self, index: u8, disposition: f32) 
        { self.disposition.retain(|d| d.index != index); }  // Will we run into problems with this if it doesn't exist, or is empty?

    fn construct_chords(&mut self) 
        { 
            self.chords.clear();
            if self.disposition.len() == 0 { return; }

            for root in self.disposition.iter().map(|d| d.tone) 
                {
                    let root_note = tone.note();
                    let mut chord_shape = Vec::new();

                    for dis in self.disposition.iter() 
                        {
                            if root != dis.tone 
                                { // This is a mess that needs to be agnostic to pitchgroups (comment generated by the AI)
                                    chord_shape.push((dis.tone.note(), Interval::distance(root.note(), dis.tone.note()).unwrap()));
                                }
                        }

                    self.chords.push(Chord{ root: root_note, intervals: chord_shape })
                }
        }

    fn find_scales(&mut self) 
        { // This is a mess that needs to be agnostic to pitchgroups
            self.scales.clear();
            if self.tones.len() == 0 { return; }

            let  scales = Vec::new();
            
            // we need to find all the scales that contain the given intervals
            // we are going to iterate over all the scales and check if the intervals are present

            self.scales = scales;
        }
}

