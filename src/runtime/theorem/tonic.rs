// ALL OF THESE LINES ARE MINE BIOTCH - 2024, Ancillary, Inc.
use std::collections::HashSet;

use super::{chord::Chord, Subsequence};
use crate::types::{Interval, Octave, PitchClass, Scale, Tone};

pub struct Tonic {
    pub note: Note,
    pub tone: Tone,        // This can give us pitch, and we could use frequency or cents
    pub index: u8,         // 0-143 - This needs to be incorporated with the wavetable
    pub velocity: u8,      // We will end up having to normalize this to a float 0.0 - 1.0
    pub harmony: u8,       // This is the type of note instance - 0 = Played, 1 = Harmonious, ?upper_bounds? = Nonce
    // This is likely where we will add a [f32; 10] for the 100 cents of a given pitchclass if we implement that level of resolution
}

impl Tonic {
    pub fn from_note(note: Note, octave: Octave, velocity: u8, harmony: u8) -> Tonic {
        let tone = Tone::from_parts(octave, note);
        Tonic { note, tone, index: tone.index(), velocity, harmony }
    }

    pub fn from_pitch_class(pc: PitchClass, octave: Octave, velocity: u8, harmony: u8) -> Tonic {
        let note = None; // This is where we need to find the note from the pitchclass
        Tonic { note, tone: Tone::from_parts(octave, note), index: tone.index(), velocity, harmony }
    }

    pub fn from_ivh(index: u8, velocity: u8, harmony: u8) -> Tonic {
        let tone = Tone::from_iv(index, velocity);
        Tonic { note: tone.note(), tone, index, velocity, harmony }
    }


pub struct TonicSet {
    pub tones: HashSet<Tonic>,  // These are the tones that are being played, where we hope to solve for note names
    pub chords: Vec<Chord>, // We need to split this further into n_inversions and n_shapes
    pub scales: Vec<Scale>,
    pub kernel: PitchGroupKernel, 
}

impl TonicSet {
    pub fn new() -> Tonic { 
        TonicSet { 
            tones: HashSet::new(), 
            chords: Vec::new(), 
            scales: Vec::new(), 
            kernel: PitchGroupKernel::new() 
        } 
    }

    fn construct_chords(&mut self, tones: HashSet<Tone>) 
        { 

            for root in tones.iter().map(|d| d.tone) 
                {
                    let root_note = tone.note();
                    let mut chord_shape = Vec::new();

                    for dis in disposition.iter() 
                        {
                            if root != dis.tone 
                                { // This is a mess that needs to be agnostic to pitchgroups (comment generated by the AI)
                                    chord_shape.push(
                                        Chord { root: dis.tone, intervals: Interval::from_tones(root, dis.tone) }   // This finds a given interval between two notes
                                    );
                                }
                        }

                    self.chords.push(Chord{ root: root_note, intervals: chord_shape })
                }
        }

    fn find_scales(&mut self) 
        { // This is a mess that needs to be agnostic to pitchgroups
            self.scales.clear();
            if self.tones.len() == 0 { return; }

            let  scales = Vec::new();
            
            // we need to find all the scales that contain the given intervals
            // we are going to iterate over all the scales and check if the intervals are present

            self.scales = scales;
        }
}